m4_divert(-1)                                                -*- C -*-

# Yacc compatible skeleton for Bison

# Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
# Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301  USA

m4_include(b4_skeletonsdir/[c.m4])

## ---------------- ##
## Default values.  ##
## ---------------- ##

# Stack parameters.
m4_define_default([b4_stack_depth_max], [10000])
m4_define_default([b4_stack_depth_init],  [200])


## ------------------------ ##
## Pure/impure interfaces.  ##
## ------------------------ ##


# b4_yacc_pure_if(IF-TRUE, IF-FALSE)
# ----------------------------------
# Expand IF-TRUE, if %pure-parser and %parse-param, IF-FALSE otherwise.
m4_define([b4_yacc_pure_if],
[b4_pure_if([m4_ifset([b4_parse_param],
		      [$1], [$2])],
	    [$2])])


# b4_yyerror_args
# ---------------
# Arguments passed to yyerror: user args plus yylloc.
m4_define([b4_yyerror_args],
[b4_yacc_pure_if([b4_locations_if([&yylloc, ])])dnl
m4_ifset([b4_parse_param], [b4_c_args(b4_parse_param), ])])


# b4_lex_param
# ------------
# Accumulate in b4_lex_param all the yylex arguments.
# b4_lex_param arrives quoted twice, but we want to keep only one level.
m4_define([b4_lex_param],
m4_dquote(b4_pure_if([[[[YYSTYPE *]], [[&yylval]]][]dnl
b4_locations_if([, [[YYLTYPE *], [&yylloc]]])m4_ifdef([b4_lex_param], [, ])])dnl
m4_ifdef([b4_lex_param], b4_lex_param)))



## ------------ ##
## Data Types.  ##
## ------------ ##

# b4_int_type(MIN, MAX)
# ---------------------
# Return the smallest int type able to handle numbers ranging from
# MIN to MAX (included).  Overwrite the version from c.m4, which
# uses only C89 types, so that the user can override the shorter
# types, and so that pre-C89 compilers are handled correctly.
m4_define([b4_int_type],
[m4_if(b4_ints_in($@,      [0],   [255]), [1], [uint8_t],
       b4_ints_in($@,   [-128],   [127]), [1], [int8_t],

       b4_ints_in($@,      [0], [65535]), [1], [uint16_t],
       b4_ints_in($@, [-32768], [32767]), [1], [int16_t],

					       [int])])


## ----------------- ##
## Semantic Values.  ##
## ----------------- ##


# b4_lhs_value(SYMBOL-NUM, [TYPE])
# --------------------------------
# See README.
m4_define([b4_lhs_value],
[b4_symbol_value((_XDPDA_VAR(yyval)), [$1], [$2])])

# b4_rhs_value(RULE-LENGTH, POS, [SYMBOL-NUM], [TYPE])
# ----------------------------------------------------
# See README.
m4_define([b4_rhs_value],
[b4_symbol_value([(_XDPDA_VAR(yyvsp))@{($2)@}], [$3], [$4])])



## b4_rhs_value(RULE-LENGTH, POS, [NUM], [TYPE])
## --------------------------------------
## Expansion of $<TYPE>NUM, where the current rule has RULE-LENGTH
## symbols on RHS.
##m4_define([b4_rhs_value],
##[((_XDPDA_VAR(yyvsp))@{($2)@}m4_ifval([$4], [.$4]))])


## --------------------------------------------------------- ##
## Defining symbol actions, e.g., printers and destructors.  ##
## --------------------------------------------------------- ##

# We do want M4 expansion after # for CPP macros.
m4_changecom()
m4_divert(0)dnl
@output(b4_parser_file_name@)
b4_copyright([Skeleton implementation for Bison's Yacc-like parsers in C],dnl '
  [1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2022])[
  
/* C XLALR(1) parser skeleton written by liang.li , tables only */

#ifndef _XDPDA_IMPLEMENT_TABLE_STORE
#define _XDPDA_IMPLEMENT_TABLE_STORE(__entry__)		__entry__
#endif /* _XDPDA_IMPLEMENT_TABLE_STORE */

   
/*
 * X1 -- _XDPDA_IMPLEMENT_IDENTIFICATION_DECLARE_ BEGIN ...
 */   
#ifdef _XDPDA_IMPLEMENT_IDENTIFICATION_DECLARE_

]b4_identification[

#endif /* _XDPDA_IMPLEMENT_IDENTIFICATION_DECLARE_ */
/*
 * X1 -- _XDPDA_IMPLEMENT_IDENTIFICATION_DECLARE_ END.
 */

/*
 * X1 -- _XDPDA_IMPLEMENT_TOKENENUMS_DECLARE_ BEGIN ...
 */
#ifdef _XDPDA_IMPLEMENT_TOKENENUMS_DECLARE_

]b4_token_enums_defines(b4_tokens)[

#endif /*_XDPDA_IMPLEMENT_TOKENENUMS_DECLARE_*/
/* 
 * X1 -- _XDPDA_IMPLEMENT_TOKENENUMS_DECLARE_ END.
 */

/*
 * X2 -- _XDPDA_IMPLEMENT_CONSTANT_DECLARE_ BEGIN ...
 */
 #ifdef _XDPDA_IMPLEMENT_CONSTANT_DECLARE_
 
/* YYFINAL -- State number of the termination state.  */
#define _XDPDACD_YYFINAL  		]b4_final_state_number[
/* YYLAST -- Last index in YYTABLE.  */
#define _XDPDACD_YYLAST   		]b4_last[

/* YYNTOKENS -- Number of terminals.  */
#define _XDPDACD_YYNTOKENS  	]b4_tokens_number[
/* YYNNTS -- Number of nonterminals.  */
#define _XDPDACD_YYNNTS  		]b4_nterms_number[
/* YYNRULES -- Number of rules.  */
#define _XDPDACD_YYNRULES  		]b4_rules_number[
/* YYNRULES -- Number of states.  */
#define _XDPDACD_YYNSTATES  	]b4_states_number[

#define _XDPDACD_YYUNDEFTOK  	YYUNDEF
#define _XDPDACD_YYMAXUTOK   	]b4_code_max[

#define _XDPDACD_YYPACT_NINF 	]b4_pact_ninf[
#define _XDPDACD_YYTABLE_NINF 	]b4_table_ninf[

#endif /* _XDPDA_IMPLEMENT_CONSTANT_DECLARE_ */
/*
 * X2 -- _XDPDA_IMPLEMENT_CONSTANT_DECLARE_ END.
 */
 
 /*
  * X3 -- _XDPDA_IMPLEMENT_STATE_TYPE_DECLARE_ BEGIN ...
  */
 #ifdef _XDPDA_IMPLEMENT_STATE_TYPE_DECLARE_
 
#define _XDPDAST_yytranslate _XDPDAST_IMPLEMENT_OF( ]b4_int_type_for([b4_translate])[ )
#define _XDPDAST_yyprhs      _XDPDAST_IMPLEMENT_OF( ]b4_int_type_for([b4_prhs])[ )
#define _XDPDAST_yyrhs       _XDPDAST_IMPLEMENT_OF( ]b4_int_type_for([b4_rhs])[ )
#define _XDPDAST_yyrline     _XDPDAST_IMPLEMENT_OF( ]b4_int_type_for([b4_rline])[ )
#define _XDPDAST_yytoknum    _XDPDAST_IMPLEMENT_OF( ]b4_int_type_for([b4_toknum])[ )
#define _XDPDAST_yyr1        _XDPDAST_IMPLEMENT_OF( ]b4_int_type_for([b4_r1])[ )
#define _XDPDAST_yyr2        _XDPDAST_IMPLEMENT_OF( ]b4_int_type_for([b4_r2])[ )
#define _XDPDAST_yydefact    _XDPDAST_IMPLEMENT_OF( ]b4_int_type_for([b4_defact])[ )
#define _XDPDAST_yydefgoto   _XDPDAST_IMPLEMENT_OF( ]b4_int_type_for([b4_defgoto])[ )
#define _XDPDAST_yypact      _XDPDAST_IMPLEMENT_OF( ]b4_int_type_for([b4_pact])[ )
#define _XDPDAST_yypgoto     _XDPDAST_IMPLEMENT_OF( ]b4_int_type_for([b4_pgoto])[ )
#define _XDPDAST_yytable     _XDPDAST_IMPLEMENT_OF( ]b4_int_type_for([b4_table])[ )
#define _XDPDAST_yycheck     _XDPDAST_IMPLEMENT_OF( ]b4_int_type_for([b4_check])[ )
#define _XDPDAST_yystos      _XDPDAST_IMPLEMENT_OF( ]b4_int_type_for([b4_stos])[ )

#endif /*_XDPDA_IMPLEMENT_STATE_TYPE_DECLARE_*/
/*
 * X3 -- _XDPDA_IMPLEMENT_STATE_TYPE_DECLARE_ END   ...
 */  
 
/*
 * X4 -- _XDPDA_IMPLEMENT_TNAME_DECLARE_ BEGIN ...
 */
#ifdef _XDPDA_IMPLEMENT_TNAME_DECLARE_
static const char *const 
_XDPDA_IMPLEMENT_TABLE_STORE(_XDPDA_IMPLEMENT_NAME_OF( yytname )[]) =
{
  ]b4_tname[
};
#endif /* _XDPDA_IMPLEMENT_TNAME_DECLARE_ */
/*
 * X4 -- _XDPDA_IMPLEMENT_TNAME_DECLARE_ END.
 */
 
/*
 * X5 -- _XDPDA_IMPLEMENT_TOKNUM_DECLARE_ BEGIN ...
 */
#ifdef _XDPDA_IMPLEMENT_TOKNUM_DECLARE_
static const 
_XDPDA_IMPLEMENT_STATE_TYPE_OF( ]b4_int_type_for([b4_toknum])[ )
_XDPDA_IMPLEMENT_TABLE_STORE(_XDPDA_IMPLEMENT_NAME_OF( yytoknum )[]) =
{
  ]b4_toknum[
};
#endif /* _XDPDA_IMPLEMENT_TOKNUM_DECLARE_ */
/*
 * X5 -- _XDPDA_IMPLEMENT_TOKNUM_DECLARE_ END.
 */ 
 
/*
 * X6 -- _XDPDA_IMPLEMENT_DBGTBL_DECLARE_ BEGIN ...
 */
#ifdef _XDPDA_IMPLEMENT_DBGTBL_DECLARE_
static const 
_XDPDA_IMPLEMENT_STATE_TYPE_OF( ]b4_int_type_for([b4_prhs])[ )
_XDPDA_IMPLEMENT_TABLE_STORE(_XDPDA_IMPLEMENT_NAME_OF( yyprhs )[]) =
{
  ]b4_prhs[
};

/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
static const 
_XDPDA_IMPLEMENT_STATE_TYPE_OF( ]b4_int_type_for([b4_rhs])[ )
_XDPDA_IMPLEMENT_TABLE_STORE(_XDPDA_IMPLEMENT_NAME_OF( yyrhs )[]) =
{
  ]b4_rhs[
};

/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
static const 
_XDPDA_IMPLEMENT_STATE_TYPE_OF( ]b4_int_type_for([b4_rline])[ )
_XDPDA_IMPLEMENT_TABLE_STORE(_XDPDA_IMPLEMENT_NAME_OF( yyrline )[]) =
{
  ]b4_rline[
};
#endif /* _XDPDA_IMPLEMENT_DBGTBL_DECLARE_ */
/*
 * X6 -- _XDPDA_IMPLEMENT_DBGTBL_DECLARE_ END.
 */
  	 
/*
 * X7 -- _XDPDA_IMPLEMENT_TABLE_DECLARE_ BEGIN ...
 */  	 
#ifdef _XDPDA_IMPLEMENT_TABLE_DECLARE_

/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
static const 
_XDPDA_IMPLEMENT_STATE_TYPE_OF( ]b4_int_type_for([b4_translate])[ )
_XDPDA_IMPLEMENT_TABLE_STORE(_XDPDA_IMPLEMENT_NAME_OF( yytranslate) []) =
{
  ]b4_translate[
};	

/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
static const 
_XDPDA_IMPLEMENT_STATE_TYPE_OF( ]b4_int_type_for([b4_r1])[ )
_XDPDA_IMPLEMENT_TABLE_STORE(_XDPDA_IMPLEMENT_NAME_OF( yyr1 )[]) =
{
  ]b4_r1[
};

/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
static const 
_XDPDA_IMPLEMENT_STATE_TYPE_OF( ]b4_int_type_for([b4_r2])[ )
_XDPDA_IMPLEMENT_TABLE_STORE(_XDPDA_IMPLEMENT_NAME_OF( yyr2 )[]) =
{
  ]b4_r2[
};

/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
   means the default is an error.  */
static const 
_XDPDA_IMPLEMENT_STATE_TYPE_OF( ]b4_int_type_for([b4_defact])[ )
_XDPDA_IMPLEMENT_TABLE_STORE(_XDPDA_IMPLEMENT_NAME_OF( yydefact )[]) =
{
  ]b4_defact[
};

/* YYDEFGOTO[NTERM-NUM].  */
static const 
_XDPDA_IMPLEMENT_STATE_TYPE_OF( ]b4_int_type_for([b4_defgoto])[ )
_XDPDA_IMPLEMENT_TABLE_STORE(_XDPDA_IMPLEMENT_NAME_OF( yydefgoto )[]) =
{
  ]b4_defgoto[
};

/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
   STATE-NUM.  */

static const 
_XDPDA_IMPLEMENT_STATE_TYPE_OF( ]b4_int_type_for([b4_pact])[ )
_XDPDA_IMPLEMENT_TABLE_STORE(_XDPDA_IMPLEMENT_NAME_OF( yypact )[]) =
{
  ]b4_pact[
};

/* YYPGOTO[NTERM-NUM].  */
static const 
_XDPDA_IMPLEMENT_STATE_TYPE_OF( ]b4_int_type_for([b4_pgoto])[ )
_XDPDA_IMPLEMENT_TABLE_STORE(_XDPDA_IMPLEMENT_NAME_OF( yypgoto )[]) =
{
  ]b4_pgoto[
};

/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
   positive, shift that token.  If negative, reduce the rule which
   number is the opposite.  If zero, do what YYDEFACT says.
   If YYTABLE_NINF, syntax error.  */

static const 
_XDPDA_IMPLEMENT_STATE_TYPE_OF( ]b4_int_type_for([b4_table])[ )
_XDPDA_IMPLEMENT_TABLE_STORE(_XDPDA_IMPLEMENT_NAME_OF( yytable )[]) =
{
  ]b4_table[
};

static const 
_XDPDA_IMPLEMENT_STATE_TYPE_OF( ]b4_int_type_for([b4_check])[ )
_XDPDA_IMPLEMENT_TABLE_STORE(_XDPDA_IMPLEMENT_NAME_OF( yycheck )[]) =
{
  ]b4_check[
};

#if 0
/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
   symbol of state STATE-NUM.  */
static const 
_XDPDA_IMPLEMENT_STATE_TYPE_OF( ]b4_int_type_for([b4_stos])[ )
_XDPDA_IMPLEMENT_TABLE_STORE(_XDPDA_IMPLEMENT_NAME_OF( yystos )[]) =
{
  ]b4_stos[
};
#endif

#endif /* _XDPDA_IMPLEMENT_TABLE_DECLARE_ */
/*
 * X7 -- _XDPDA_IMPLEMENT_TABLE_DECLARE_ END.
 */   

/**
 *!
 */
#undef _XDPDA_IMPLEMENT_TABLE_STORE

#ifdef _XDPDA_IMPLEMENT_USER_ACTIONS_DECLARE_
/*
 * X8 -- _XDPDA_IMPLEMENT_USER_ACTIONS_DECLARE_ BEGIN ...
 */

]b4_user_actions[

/*
 * X8 -- _XDPDA_IMPLEMENT_USER_ACTIONS_DECLARE_ END.
 */
#endif /* _XDPDA_IMPLEMENT_USER_ACTIONS_DECLARE_ */

]

